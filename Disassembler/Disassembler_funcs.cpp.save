#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "../Commands.h"
#include "Disassembler_funcs.h"
#include "../Stack.h"
#include "../Text_funcs.h"

int disassembler_translate(const char* input_name, const char* output_name) {
    assert(input_name != NULL);
    assert(output_name != NULL);

    FILE* byte_code      = fopen(input_name, "rb");
    FILE* assembler_code = fopen(output_name, "w");
    struct bin code = {NULL, 0, 0, 0};
    code.bin_file_len = file_len(byte_code);
    code.bin_file = (char*) calloc(code.bin_file_len, sizeof(char));
    int command = 0;

    while (code.bin_shift < code.bin_file_len) {
        command = *((Commands_t*) (code.bin_file + code.bin_shift));
        printf("%ld %d", code.id, co)
        code.id++;
        code.bin_shift += sizeof(Commands_t);
        switch (command) {
        case PUSH:
            if (distranslate_push(&code, assembler_code) == 1) {
                return 1;
            }
            break;
        case PUSHR:
            if (distranslate_pushr(&code, assembler_code) == 1) {
                return 1;
            }
            break;
        case POP:
            if (distranslate_pop(&code, assembler_code) == 1) {
                return 1;
            }
            break;
        case IN:
            distranslate_in(assembler_code);
            break;
        case OUT:
            distranslate_out(assembler_code);
            break;
        case HLT:
            distranslate_HLT(assembler_code);
            break;
        case ADD:
            distranslate_add(assembler_code);
            break;
        case SUB:
            distranslate_sub(assembler_code);
            break;
        case MUL:
            distranslate_mul(assembler_code);
            break;
        case DIV:
            distranslate_div(assembler_code);
            break;
        case SQRT:
            distranslate_sqrt(assembler_code);
            break;
        case SIN:
            distranslate_sin(assembler_code);
            break;
        case COS:
            distranslate_cos(assembler_code);
            break;
        default:
            wrong_command_code(command);
            return 1;
            break;
        }
    }
    fclose(byte_code);
    fclose(assembler_code);

    return 0;
}

int distranslate_push(bin* code, FILE* assembler_code) {
    assert(assembler_code != NULL);
    assert(code != NULL);

    Elem_t x = 0;
    x = *((Elem_t*) (code->bin_file + code->bin_shift));
    code->id++;
    code->bin_shift += sizeof(Elem_t);
    fprintf(assembler_code, "push %lf\n", x);

    return 0;
}

int distranslate_pushr(bin* code, FILE* assembler_code) {
    assert(assembler_code != NULL);
    assert(code != NULL);

    unsigned char registr = 0;
    registr = *((Registr_code_t*) (code->bin_file + code->bin_shift));
    code->id++;
    code->bin_shift += sizeof(Registr_code_t);
    switch (registr) {
        case A:
            fprintf(assembler_code, "pushr rax\n");
            break;
        case B:
            fprintf(assembler_code, "pushr rbx\n");
            break;
        case C:
            fprintf(assembler_code, "pushr rcx\n");
            break;
        case D:
            fprintf(assembler_code, "pushr rdx\n");
            break;
        default:
            wrong_registr(registr);
            return 1;
            break;
    }

    return 0;
}

int distranslate_pop(bin* code, FILE* assembler_code) {
    assert(assembler_code != NULL);
    assert(code != NULL);

    unsigned char registr = 0;
    registr = *((Registr_code_t*) (code->bin_file + code->bin_shift));
    code->id++;
    code->bin_shift += sizeof(Registr_code_t);
    switch (registr) {
        case A:
            fprintf(assembler_code, "pop rax\n");
            break;
        case B:
            fprintf(assembler_code, "pop rbx\n");
            break;
        case C:
            fprintf(assembler_code, "pop rcx\n");
            break;
        case D:
            fprintf(assembler_code, "pop rdx\n");
            break;
        default:
            wrong_registr(registr);
            return 1;
            break;
    }

    return 0;
}

void distranslate_in(FILE* assembler_code) {
    assert(assembler_code != NULL);

    fprintf(assembler_code, "in\n");
}

void distranslate_out(FILE* assembler_code) {
    assert(assembler_code != NULL);

    fprintf(assembler_code, "out\n");
}

void distranslate_HLT(FILE* assembler_code) {
    assert(assembler_code != NULL);

    fprintf(assembler_code, "HLT\n");
}

void distranslate_add(FILE* assembler_code) {
    assert(assembler_code != NULL);

    fprintf(assembler_code, "add\n");
}

void distranslate_sub(FILE* assembler_code) {
    assert(assembler_code != NULL);

    fprintf(assembler_code, "sub\n");
}

void distranslate_mul(FILE* assembler_code) {
    assert(assembler_code != NULL);

    fprintf(assembler_code, "mul\n");
}

void distranslate_div(FILE* assembler_code) {
    assert(assembler_code != NULL);

    fprintf(assembler_code, "div\n");
}

void distranslate_sqrt(FILE* assembler_code) {
    assert(assembler_code != NULL);

    fprintf(assembler_code, "sqrt\n");
}

void distranslate_sin(FILE* assembler_code) {
    assert(assembler_code != NULL);

    fprintf(assembler_code, "sin\n");
}

void distranslate_cos(FILE* assembler_code) {
    assert(assembler_code != NULL);

    fprintf(assembler_code, "cos\n");
}

void wrong_command(char* str_command) {
    assert(str_command != NULL);

    fprintf(stderr, "WRONG COMMAND: %s\n", str_command);
}

void wrong_command_code(int command) {
    fprintf(stderr, "WRONG COMMAND: %d\n", command);
}

void wrong_push() {
    fprintf(stderr, "WRONG PUSH\n");
}

void wrong_pop() {
    fprintf(stderr, "WRONG POP\n");
}

void wrong_registr(int registr) {
    fprintf(stderr, "WRONG REGISTR: %d\n", registr);
}
