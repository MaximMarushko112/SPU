#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "../Commands.h"
#include "Disassembler_funcs.h"
#include "../Stack.h"
#include "../Text_funcs.h"

int disassembler_translate(const char* input_name, const char* output_name) {
    assert(input_name != NULL);
    assert(output_name != NULL);

    FILE* byte_code      = fopen(input_name, "rb");
    FILE* assembler_code = fopen(output_name, "w");
    struct bin code = {NULL, 0, 0, 0};
    code.bin_file_len = file_len(byte_code);
    code.bin_file = (char*) calloc(code.bin_file_len, sizeof(char));
    fread(code.bin_file, sizeof(char), code.bin_file_len, byte_code);
    int command = 0;

    while (code.bin_shift < code.bin_file_len) {
        command = *((Commands_t*) (code.bin_file + code.bin_shift));
        code.id++;
        code.bin_shift += sizeof(Commands_t);
        switch (command) {
        case PUSH:
            if (distranslate_push(&code, assembler_code) == 1) {
                return 1;
            }
            break;
        case PUSHR:
            if (distranslate_pushr(&code, assembler_code) == 1) {
                return 1;
            }
            break;
        case POP:
            if (distranslate_pop(&code, assembler_code) == 1) {
                return 1;
            }
            break;
        case IN:
            distranslate_in(assembler_code);
            break;
        case OUT:
            distranslate_out(assembler_code);
            break;
        case HLT:
            distranslate_HLT(assembler_code);
            break;
        case ADD:
            distranslate_add(assembler_code);
            break;
        case SUB:
            distranslate_sub(assembler_code);
            break;
        case MUL:
            distranslate_mul(assembler_code);
            break;
        case DIV:
            distranslate_div(assembler_code);
            break;
        case SQRT:
            distranslate_sqrt(assembler_code);
            break;
        case SIN:
            distranslate_sin(assembler_code);
            break;
        case COS:
            distranslate_cos(assembler_code);
            break;
        default:
            wrong_command_code(command);
            return 1;
            break;
        }
    }
    fclose(byte_code);
    fclose(assembler_code);

    return 0;
}

int distranslate_push(bin* code, FILE* assembler_code) {
    assert(assembler_code != NULL);
    assert(code != NULL);

    Elem_t x = 0;
    x = *((Elem_t*) (code->bin_file + code->bin_shift));
    code->id++;
    code->bin_shift += sizeof(Elem_t);
    fprintf(assembler_code, "push %lf\n", x);

    return 0;
}

#define REGISTR_DISTRANSLATE(name)                                          \
    int distranslate_##name(bin* code, FILE* assembler_code) {              \
        assert(assembler_code != NULL);                                     \
        assert(code != NULL);                                               \
                                                                            \
        unsigned char registr = 0;                                          \
        registr = *((Registr_code_t*) (code->bin_file + code->bin_shift));  \
        code->id++;                                                         \
        code->bin_shift += sizeof(Registr_code_t);                          \
        switch (registr) {                                                  \
            case A:                                                         \
                fprintf(assembler_code, "##name rax\n");                    \
                break;                                                      \
            case B:                                                         \
                fprintf(assembler_code, "##name rbx\n");                    \
                break;                                                      \
            case C:                                                         \
                fprintf(assembler_code, "##name rcx\n");                    \
                break;                                                      \
            case D:                                                         \
                fprintf(assembler_code, "##name rdx\n");                    \
                break;                                                      \
            default:                                                        \
                wrong_registr(registr);                                     \
                return 1;                                                   \
                break;                                                      \
        }                                                                   \
                                                                            \
        return 0;                                                           \
    }

REGISTR_DISTRANSLATE(pushr)

REGISTR_DISTRANSLATE(pop)

#define SIMPLE_DISTRANSLATE(name, command)                     \
    void distranslate_##name(FILE* assembler_code) {  \
        assert(assembler_code != NULL);               \
                                                      \
        fprintf(assembler_code, "name\n");            \
    }

SIMPLE_DISTRANSLATE("in")

SIMPLE_DISTRANSLATE(out)

SIMPLE_DISTRANSLATE(HLT)

SIMPLE_DISTRANSLATE(add)

SIMPLE_DISTRANSLATE(sub)

SIMPLE_DISTRANSLATE(mul)

SIMPLE_DISTRANSLATE(div)

SIMPLE_DISTRANSLATE(sqrt)

SIMPLE_DISTRANSLATE(sin)

SIMPLE_DISTRANSLATE(cos)

void wrong_command_code(int command) {
    fprintf(stderr, "WRONG COMMAND: %d\n", command);
}

void wrong_registr(unsigned char registr) {
    fprintf(stderr, "WRONG REGISTR: %d\n", registr);
}
